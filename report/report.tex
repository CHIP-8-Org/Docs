\documentclass[a4paper]{article}

\usepackage{showcode/showcode}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{bm}

% \begin{center}
% \showc*[.75\textwidth]{test.c}
% \end{center}

% \begin{Listing} % [ht]
%     \centering
%         \showc*[.5\textwidth]{test.c}
%         \caption{A C program.}\label{c}
% \end{Listing}

\usepackage[a4paper]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage{eurosym}
\usepackage{caption, subcaption}
\usepackage{tikz, circuitikz}
\usepackage{pgf-umlcd, pgf-umlsd}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\renewcommand{\umltextcolor}{black}
\renewcommand{\umldrawcolor}{black}
\renewcommand{\umlfillcolor}{white}

% \setlength{\parskip}{1.2ex}
% \setlength{\parindent}{0em}
% \clubpenalty = 100
% \widowpenalty = 100

% \title{CHIP-8 STM32}
% \date{\today}
% \author{Federico Bruzzone, Lorenzo Ferrante, Andrea Longoni \\
% \footnotesize \texttt{\{federico.bruzzone, lorenzo.ferrante1, andrea.longoni3\}@studenti.unimi.it} \\ }



\textwidth=450pt
\oddsidemargin=0pt
\textheight=665pt
\voffset=-50pt

% \singlespacing

\begin{document}
% \maketitle
% \newpage

\begin{titlepage}
	\begin{center}
		\includegraphics[height=5cm]{minerva.pdf}

		\vspace*{1.75cm}

		\LARGE

		\textbf{MSc in Computer Science} \\
		at University of Milan

		\vspace*{1cm}

		\huge
		CHIP-8 STM32

		\large Proposta per il Progetto di PROS, \\
		corso tenuto da \textbf{Danilo Bruschi}

		\normalsize
		\vspace*{4cm}

		\begin{minipage}[t]{0.47\textwidth}
			{Email: } \vspace{0.3em} \\
			{\large \href{federico.bruzzone@studenti.unimi.it}{federico.bruzzone@studenti.unimi.it}} \vspace{1em}  \\
			{\large \href{lorenzo.ferrante1@studenti.unimi.it}{lorenzo.ferrante1@studenti.unimi.it}} \vspace{1em}  \\
			{\large \href{andrea.longoni3@studenti.unimi.it}{andrea.longoni3@studenti.unimi.it}} \vspace{1em}  \\
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.47\textwidth}\raggedleft
			{Creato da:} \hspace{-0.9em} \vspace{0.3em} \\
			{\large \textbf{Federico Bruzzone}} \\
			\vspace{1em}
			{\large \textbf{Lorenzo Ferrante}} \\
			\vspace{1em}
			{\large \textbf{Andrea Longoni}}
		\end{minipage}

		\vfill
		Anno accademico 2022/2023

	\end{center}
\end{titlepage}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.8em}
% \linespread{1.5}

\tableofcontents
\listoffigures
\listoftables

\newpage

\section{Introduzione}

% TODO: includere una foto dell'emulatore finito e funzionante

CHIP-8 è un linguaggio di programmazione creato a metà degli anni '70
da Joseph Weisbecker per semplificare lo sviluppo di videogiochi per
microcomputer a 8 bit. I programmi CHIP-8 vengono interpretati da una
macchina virtuale che è stata estesa parecchie volte nel corso degli
anni, tra le versioni più adottate citiamo S-CHIP e la più recente
XO-CHIP.

La semplicità dell'interprete in aggiunta alla sua lunga storia e
popolarità hanno fatto sì che emulatori e programmi CHIP-8 vengano
realizzati ancora oggi.
Nel corso degli anni molti videogiochi storici sono stati riscritti
in CHIP-8 tra cui Pong, Space Invaders e Tetris.

Lo scopo del progetto è quello di costruire un emulatore CHIP-8 e
S-CHIP in grado di funzionare su un microcontrollore STM32.

In questo documento ci riferiremo alla macchina virtuale che
interpreta programmi CHIP-8 con "interprete". Mentre utilizzeremo
"emulatore" per indicare l'interprete assieme ad una sua
implementazione (o "port"), ovvero un programma che gestisce
l'audio, il video, l'input da tastiera e interagisce con l'API della
macchina virtuale.

\section{Stato dell'arte}

Al giorno d'oggi risulta difficile ottenere un numero esatto di utenti che utilizzano CHIP-8, un buon indicatore puo' essere il topic "chip8" di GitHub che raggruppa quasi un migliaio di repository.

Tra queste la più popolare è Octo, un'implementazione scritta in JavaScript capace di eseguire la versione base di CHIP-8, S-CHIP e XO-CHIP nel browser. La repository è mantenuta da John Earnest, l'inventore di XO-CHIP che nel 2014 ha riportato in vita CHIP-8 modernizzandolo e aggiungendo nuove funzionalità.

Inoltre ogni anno viene organizzata la Octojam, una game jam dove ogni partecipante prova a sviluppare un videogioco per CHIP-8 (o per le sue estensioni) partendo da zero.

Grazie al suo instruction set ridotto e alla sua limitata richiesta di risorse hardware è stato portato su un elevato numero di piattaforme, tra cui il Game Boy Color, calcolatrici grafiche serie HP 48 e Emacs (il famoso editor di testo).

Sebbene CHIP-8 e S-CHIP siano stati tradizionalmente implementati tramite software esistono anche implementazioni hardware. Ne citiamo una in particolare scritta nel linguaggio Verilog per schede FPGA.

\section{Hardware}\label{sec:hardware}

Le componenti principali utilizzate per la relizzazione del progetto sono 5:
una scheda ST \texttt{STM32F334R8T6} (Fig. \ref{fig:stm32f334}), uno schermo
TFT LCD ILI9341 (Fig. \ref{fig:ili9341}), e un lettore di schede microSD
integrato nello schermo, un tastierino matriciale 4$\times$4 e un beeper.

Il componente principale é il microcontrollore \texttt{STM32F334R8T6} basato su
architettura ARM con processore Cortex-M4 da 72 \texttt{MHz}, 64 \texttt{Kb} di
memoria flash e 16 \texttt{Kb} di SRAM. Abbiamo deciso di utilizzare questa
scheda perché le ROM dei giochi CHIP-8 e S-CHIP hanno dimensione massima di 4
\texttt{Kb}. Considerando questo e il fatto che la macchina virtuale necessita
4 \texttt{Kb} per poter funzionare non è stato potuto utilizzare la scheda
\texttt{STM32L053R8T6} fornitaci durante il corso a causa della sua quantità
limita di SRAM, precisamente 8 \texttt{Kb}.


\begin{figure}[h!t]
    \begin{subfigure}[b]{0.45\textwidth}
        \begin{center}
            \includegraphics[scale=0.15]{figures/stm32f334.jpg}
        \end{center}
        \caption{Il microcontrollore \texttt{STM32F334R8T6}.}
        \label{fig:stm32f334}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \begin{center}
            \begin{tikzpicture}[x=0.015cm, y=0.015cm, scale=0.50, transform shape]
                \input{figures/stm32f334.tex}
            \end{tikzpicture}
        \end{center}
        \caption{Pinout del microcontrollore \texttt{STM32F334R8T6}.}
        \label{fig:pinout_stm32}
    \end{subfigure}
\end{figure}

Il secondo componente che abbiamo utilizzato é un display TFT LCD
(thin-film-transistor liquid-crystal display) a colori retroilluminato
(Fig. \ref{fig:ili9341}),
per poterci interfacciare con l'emulatore. Questo display, da 2.4 pollici,
é basato sul controller \texttt{ILI9341} e ha una risoluzione di
320$\times$240 \texttt{px}.

\begin{figure}[h!t]
    \begin{subfigure}[b]{0.45\textwidth}
        \begin{center}
            \includegraphics[scale=0.30]{figures/ili9341.png}
        \end{center}
        \caption{Lo schermo ILI9341.}
        \label{fig:ili9341}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \begin{center}
            \begin{tikzpicture}[x=0.015cm, y=0.015cm, scale=0.65, transform shape]
                \input{figures/ili9341.tex}
            \end{tikzpicture}
        \end{center}
        \caption{Pinout dello schermo \texttt{ILI9341}.}
        \label{fig:pinout_ili}
    \end{subfigure}
\end{figure}

Il terzo componente é un lettore di schede microSD integrato nello schermo
(Fig. \ref{fig:ili9341}). Questo componente é basato sul controller
\texttt{ILI9341} che permette di interfacciarsi con una microSD formattata in
FAT32, sulla quale é possibile salvare file di dimensione massima 4 \texttt{Gb}
e per un totale di 2 \texttt{Tb} di dati.

Per interagire con l'emulatore abbamo utilizzato una tastiera matriciale 4$\times$4
corrispondente alla tastiera esadecimale originale del CHIP-8 (Fig. \ref{fig:4x4_keypad}).

\begin{figure}[h!t]
    \begin{subfigure}[b]{0.45\textwidth}
        \begin{center}
            \includegraphics[scale=0.090]{figures/4x4_keypad.jpeg}
        \end{center}
        \caption{Il tastierino matriciale 4$\times$4.}
        \label{fig:4x4_keypad}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \begin{center}
            \includegraphics[scale=0.30]{figures/4x4_keypad_structure.png}
        \end{center}
        \caption{Struttura del tastierino matriciale 4$\times$4.}
        \label{fig:4x4_keypad_structure}
    \end{subfigure}
\end{figure}

Come ultimo componenete, per riprodurre gli effetti sonori generati dal gioco
un beeper passivo monotono é stato collegato al microcontrollore tramite un
GPIO output e GND. In CHIP-8 e S-CHIP vi é un solo frequenza che può
essere riprodotta durante tutta l'esecuzione del gioco.

In oltre, abbiamo deciso di aggiungere uno slot per l'alimentazione tramite
due batterie \texttt{AA}.

\subsection{Schema di collegamento}

\subsubsection{Legenda dei colori in Figura \ref{fig:schematic}}

\begin{itemize}
    \item \textcolor{green}{Verde}: Schermo
    \item \textcolor{blue}{Blu}: Scheda microSD
    \item \textcolor{magenta}{Magenta}: Tastierino
    \item \textcolor{orange}{Arancione}: Beeper
    \item \textcolor{cyan}{Ciano}: Reset
    \item \textcolor{black}{Nero}: GND
    \item \textcolor{red}{Rosso}: Alimentazione
\end{itemize}

\begin{figure}[h!t]
    \begin{center}
        \includegraphics[scale=0.50]{figures/STM32_CHIP8.pdf}
    \end{center}
    \caption{
        Schematic del progetto.
    }
    \label{fig:schematic}
\end{figure}

\subsubsection{Descrizione del collegamento dei componenti}

In Figura \ref{fig:schematic} é possibile vedere lo schema di collegamento
delle componenti utilizzate per la realizzazione del progetto. Per realizzare lo schema é stato utilizzato il software \texttt{KiCad}. E' importante notare, che lo schermo \texttt{ILI9341} e l'integrato lettore di schede microSD, utilizza lo pinout standard degli Shields di Arduino, ovvero un'interfaccia hardware che permette di collegare una scheda Arduino ad un modulo esterno. Quindi, é stato collegato al nostro microcontrollore STM32 utilizzando lo stesso pinout.

Il tastierino matriciale 4$\times$4 é stato collegato al microcontrollore tramite 8 pin GPIO. In particolare i 4 pin relativi alle righe (\texttt{R1}, \texttt{R2}, \texttt{R3}, \texttt{R4}) sono stati impostati in modalitá \texttt{GPIO\_MODE\_IT\_RISING} (interrupt rising edge). Quando si configura un pin GPIO come sorgente di interrupt su un fronte di salita, significa che l'interrupt verrà generato quando il livello logico del pin passa da basso (0) a alto (1). Questo è utile, ad esempio, quando si desidera intercettare un cambiamento di stato su un pulsante quando viene premuto. Invece, i 4 pin relativi alle colonne (\texttt{C1}, \texttt{C2}, \texttt{C3}, \texttt{C4}) sono stati impostati in modalitá \texttt{GPIO\_MODE\_OUTPUT\_PP} (push-pull output) per permettere l'invio dell'interrupt alla pressione di un tasto, dato che chiudendo il circuito permettiamo alla corrente proveniente dal pin GPIO di fluire verso i pin di interrupt. Successivamente, viene identificato il tasto premuto TODO.

L'ultimo componente é il beeper, che é stato collegato al microcontrollore tramite un pin GPIO e GND. Il pin GPIO é stato impostato in modalitá \texttt{GPIO\_MODE\_OUTPUT\_PP} (push-pull output) per permettere l'invio di un segnale al beeper.


\subsection{Componenti utilizzati e relativi costi}

\begin{table}[h!t] % [ht]
    \centering
    \begin{tabular}{|llll|l|}
        \hline
        \multicolumn{1}{|l|}{\textbf{Descrizione}}          & \multicolumn{1}{l|}{\textbf{Modello}}       & \multicolumn{1}{l|}{\textbf{Costo unitario}} & \textbf{Unità} & \textbf{Costo} \\ \hline
        \multicolumn{1}{|l|}{Microcontrollore}       & \multicolumn{1}{l|}{STM32 F334R8T6}         & \multicolumn{1}{l|}{14.99}                   & 1               & 14.99          \\ \hline
        \multicolumn{1}{|l|}{Schermo}                & \multicolumn{1}{l|}{ILI9341 2.4"}           & \multicolumn{1}{l|}{6.50}                    & 1               & 6.50           \\ \hline
        \multicolumn{1}{|l|}{Tastierino}          & \multicolumn{1}{l|}{Matrix keypad 4$\times$4} & \multicolumn{1}{l|}{3.99}                    & 1               & 3.99           \\ \hline
        \multicolumn{1}{|l|}{Beeper}                 & \multicolumn{1}{l|}{}                       & \multicolumn{1}{l|}{0.99}                    & 1               & 0.99           \\ \hline
        \multicolumn{1}{|l|}{Breadboard e cablaggio} & \multicolumn{1}{l|}{}                       & \multicolumn{1}{l|}{4.99}                    & 1               & 4.99           \\ \hline
        \multicolumn{4}{|r|}{\textbf{Totale}}                                                      & 31.50\euro    \\ \hline
    \end{tabular}
    \caption{
        Materiali utilizzati per la costruzione del progetto.
    }
    \label{tab:components}
\end{table}

In Tabella \ref{tab:components} é possibile vedere i componenti utilizzati per la realizzazione del progetto. I costi indicati provengono da negozi online come Amazon e eBay.

\section{Software}

Il nostro software si divide in due componenti principali: l'interprete CHIP-8 e l'infrastruttura necessaria per "portarlo" sul microcontrollore STM32, ovvero l'interfaccia con lo schermo e i gestori per la scheda microSD, per il keypad e per il beeper come gia' anticipato nella sezione \ref{sec:hardware}.

\subsection{Interprete CHIP-8}

Abbiamo deciso di scrivere l'interprete da zero e per farlo è stato necessario consultare le specifiche (de facto standard) che definiscono il comportamento di un interprete CHIP-8 \cite{cowgod:chip8} e S-CHIP \cite{cowgod:schip}.

L'interprete ha un'architettura basata su registri e possiede 4 KB di memoria, 16 registri general purpose, un registro per gli indirizzi di memoria, un registro per il delay timer, un registro per il sound timer, uno stack per gestire le chiamate a subroutine, uno stack pointer e un program counter, come si puo` vedere nel listato \ref{chip8_struct}.

\begin{Listing}[h!t] % [ht]
    \centering
    \showc*{chip8_struct.c} %[.5\textwidth]
    \caption{Struttura dell'emulatore Chip8}
    \label{chip8_struct}
\end{Listing}

Il delay timer viene utilizzato come cronometro mentre il sound
timer è utilizzato per gestire gli effetti sonori, quando il suo
valore è diverso da zero, l'emulatore attiva il beeper.

Ad ogni ciclo di esecuzione l'interprete effettua il fetch
dell'istruzione puntata dal program counter in memoria,
la decodifica e la esegue.

Sono supportate 45 istruzioni diverse, ciascuna delle
quali è rappresentata da uno specifico opcode in cui al suo interno
sono passati anche eventuali parametri.

Il programma è scritto in C99, non ha I/O ed è freestanding
\cite{n1256:conformance}, ovvero non dipende dalla libreria
standard del C (libc). Tutto questo è mirato a rendere l'interprete
altamente portabile.

Per rimuovere la dipendenza da libc è stato necessario includere
alcune funzioni direttamente da libgcc, in particolare abbiamo re-implementato
le funzioni \texttt{memset} e \texttt{memcpy}
(listato \ref{libgcc_memset_memcpy}). Inoltre, abbiamo trovato un modo
alternativo per implementare le asserzioni e includere una funzione ad hoc per
la generazione di numeri casuali.

\begin{Listing}[h!t]
\centering
\mbox{
  \showc[.45\textwidth]{libgcc_memset.c}
  \quad
  \showc[.50\textwidth]{libgcc_memcpy.c}
}
\caption{Implementazioni di \texttt{memset} e \texttt{memcpy}}
\label{libgcc_memset_memcpy}
\end{Listing}

Infine per testare più comodamente l'interprete abbiamo sviluppato
un semplice emulatore su desktop utilizzando SDL2
\cite{libsdl:about}, una libreria scritta in C che consente di
gestire audio, video e input da tastiera.
In seguito l'interprete è stato sottoposto ad un'apposita
test suite \cite{github:chip8-test-suite} che mira a verificare
il comportamento corretto di ciascun opcode.

\subsubsection{Gestione del timing}

Uno dei problemi principali durante lo sviluppo di un emulatore è
la gestione del timing, in particolare è necessario limitare la
"velocità" dell'emulatore bloccando temporaneamente la sua
esecuzione.

Inoltre abbiamo dovuto disaccoppiare la frequenza dell'interprete
(regolabile dal giocatore) dalla frequenza del delay timer e del
sound timer (costante a 60 Hz). Dove con frequenza dell'interprete
ci riferiamo al numero di istruzioni che esegue ogni frame.

% Durante lo sviluppo abbiamo testato due soluzioni diverse.

Inizialmente abbiamo optato per la gestione di una singola istruzione
per ciclo di esecuzione, di conseguenza il ritardo del game loop
risultava variabile e dipendeva dalla frequenza selezionata dal
giocatore. Per assicurare una frequenza di 60 Hz i timer
venivano decrementati ogni n-esima iterazione del game loop, dove
n = FREQ / 60. Ad esempio se FREQ = 540, i timer venivano
decrementati ogni 9º ciclo.

Purtroppo però questo approccio presenta un problema non
trascurabile, ovvero effettua una chiamata ad una funzione
simil-sleep per un periodo molto breve dopo ogni istruzione.
Ad esempio se FREQ = 540, il ritardo di una sleep sarebbe solo
di 1.85 ms, e questo genere di funzione non offre una precisione
simile. Per questo motivo abbiamo optato per una soluzione
differente.

Abbiamo fissato il ritardo del game loop a 16.666 ms, un valore
sufficientemente alto da non avere problemi di granularità. Inoltre
in questo modo otteniamo un frame rate di 60 fps esatti. Avendo
reso il ritardo costante abbiamo dovuto rendere variabile il numero
di istruzioni gestite durante un ciclo di esecuzione. In particolare
vengono gestite n istruzioni per ciclo, dove n = FREQ / 60.
Ad esempio se FREQ = 540, vengono gestite 9 istruzioni per ciclo.
A questo punto dato che il game loop viene ripetuto con una
frequenza di 60 Hz risulta banale gestire la frequenza dei timer.

Sono state considerate anche eventuali problematiche che sarebbero
potute sorgere con questo approccio. In particolare non tutte le
istruzioni impiegano lo stesso tempo per essere eseguite, ma
fortunatamente anche l'istruzione più lenta richiede una quantità
trascurabile di tempo. Ciò significa che possiamo
comportarci come se tutte le istruzioni richiedessero il medesimo
tempo.

\subsubsection{Ottimizzazioni}

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.50]{figures/screenopt.pdf}
    \end{center}
    \caption{Esempio della mappatura di un pixel.}
    \label{fig:screenopt}
\end{figure}

È stato necessario introdurre delle ottimizzazioni all'interno
dell'interprete per poterlo far girare su un microcontrollore.

L'ottimizzazione principale è legata alla rappresentazione dello
schermo in memoria. Ad alto livello lo schermo può essere visto
come una matrice di 128x64 pixel monocromi. Una rappresentazione
simile occuperebbe 8192 byte, dato che ciascun pixel verrebbe
rappresentato da un byte.

Purtroppo il nostro microcontrollore ha a disposizione solamente
16 KB di SRAM, di conseguenza una soluzione simile non è praticabile.

Per questo motivo abbiamo deciso di rappresentare lo schermo come
un array unidimensionale di 1024 byte, dove ciascun pixel viene
rappresentato da un singolo bit. In questo modo otteniamo un
risparmio di spazio pari a ben l'87.5\%.

Questa decisione ha aggiunto però un livello di indirezione dato
che una coordinata ad alto livello sulla matrice 128x64 é mappata
ad una coordinata "in memoria", dove la prima componente é l'indice
del byte nell'array unidimensionale e la seconda componenete é il bit
all'interno del byte. La figura [\ref{fig:screenopt}] mostra un esempio
di mappatura di un pixel. Piú precisamente la funzione $F$ é definita
come segue:
\begin{gather*}
    F: \mathbb{N} \times \mathbb{N} \rightarrow \mathbb{N} \times \mathbb{N} \\
    F(x, y) = \left(\left\lfloor \frac{128y + x}{8} \right\rfloor, 7 - (x \bmod 8)\right) \\
    where \quad x \in [0, 127] \quad y \in [0, 63] \\
\end{gather*}

Un'ulteriore ottimizzazione viene resa disponibile attraverso l'API
dell'interprete sotto forma di una funzione che consente al chiamante
di controllare se l'array che rappresenta lo schermo è stato
modificato nell'ultimo ciclo di esecuzione. Avendo notato che il numero di
opcode che modificano lo schermo è molto limitato, precisamente sono solo 7 su
45, questa funzione consente di ridurre di 6.42 volte il numero di volte in cui
lo schermo viene aggiornato.

\subsubsection{SD}

Un'ulteriore ottimizzazione é stata di non abilitare il
Long File Names (LFN) sul filesystem FAT32 della scheda microSD,
quindi tutti i file devono avere un nome di al massimo 13 byte
(caratteri ASCII).
In questo modo abbiamo risparmiato in termini complessitá di computazione,
memoria flash e SRAM.



\subsubsection{Comportamenti ambigui}

Gli interpreti CHIP-8 e S-CHIP hanno sviluppato molteplici
comportamenti ambigui nel corso degli anni. Questi cosiddetti
"quirk" variano in base alle piattaforme per cui è stato sviluppato
l'interprete. Ad esempio gli interpreti per calcolatrici HP48
presentano un comportamento leggermente diverso durante l'esecuzione
delle istruzioni di SHIFT.

Questi comportamenti ambigui si propagano fino ai programmatori
CHIP-8 che si appoggiano a quest'ultimi e scrivono videogiochi che
non sono del tutto compatibili con interpreti più vecchi. Per evitare
questa frammentazione è necessario supportare le piattaforme
principali e i loro quirk.

Il nostro interprete supporta CHIP-8, CHIP-48, S-CHIP 1.0 e
S-CHIP 1.1, in questo modo è in grado di eseguire la stragrande
maggioranza dei videogiochi reperibili in rete.

\subsection{Porting su STM32}

Successivamente, viene capito quale tasto é stato premuto, leggendo il valore dei pin di riga e di colonna. Per fare ció, i pin di riga sono stati impostati in modalitá \texttt{GPIO\_MODE\_INPUT} (input floating) e i pin di colonna in modalitá \texttt{GPIO\_MODE\_INPUT} (input pull-up). Questo significa che i pin di colonna sono collegati a VCC tramite una resistenza di pull-up, mentre i pin di riga sono collegati a GND tramite un pulsante. Quando il pulsante viene premuto, il pin di riga viene collegato a GND e il pin di colonna viene collegato a VCC, quindi il valore del pin di riga diventa 0 e il valore del pin di colonna diventa 1. In questo modo, é possibile capire quale tasto é stato premuto.

\subsubsection{Interfaccia con lo schermo}

\subsubsection{Gestori per le ulteriori periferiche}

\subsubsection{Menù di selezione}

\subsection{Architettura}

% TODO: aggiornare il class diagram e il sequence diagram

% \section{Assemblaggio}

% TODO

\section{Analisi del consumo energetico} % ALT: Alimentazione e consumi

% TODO

\section{Considerazioni finali} % ALT: Conclusioni e sviluppi futuri

\section{Sviluppi futuri}

Aggiornare solo la sprite che è stata modificata.

% TODO

\addcontentsline{toc}{section}{Riferimenti bibliografici}
\bibliographystyle{plain}
\bibliography{report}

\end{document}
